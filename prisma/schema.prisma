// Playgram v3.0 Database Schema
// Complete schema for all 42 features

generator client {
  provider = "prisma-client-js"
}

model QRToolConfig {
  id                   String   @id @default(cuid())
  toolId               String   @unique
  formatPattern        String?
  fallbackUrl          String?
  appearance           Json?
  fieldMappings        Json?
  securityPolicy       Json?
  metadata             Json?
  scannerInstructions  String?  // Custom instructions shown before scanning
  displayFields        Json?    // Array of field names to parse and display

  // Recurring campaign settings
  isRecurring          Boolean  @default(false) // Enable recurring QR generation
  maxCodesPerUser      Int?     // Max codes per user (null = infinite)
  rewardThreshold      Int?     // Scans needed for reward (e.g., 7 for coffee card)
  autoResetOnReward    Boolean  @default(true)  // Reset progress after reward
  startingStreak       Int      @default(0)     // Starting progress for new users
  recurringConfig      Json?    // Additional recurring settings

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

// =========================================================================
// ENUMERATIONS
// =========================================================================

enum DynamicGallerySourceType {
  webhook
  api
  manual
}

enum DynamicGalleryTriggerType {
  manual
  webhook
  schedule
}

enum DynamicGallerySyncStatus {
  success
  warning
  failed
}

// ============================================================================
// AUTHENTICATION & AUTHORIZATION
// ============================================================================

model Admin {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String
  name          String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastLogin     DateTime?

  // Relations
  tools                    Tool[]
  manychatConfig           ManychatConfig?
  tags                     Tag[]
  webhookSubscriptions     WebhookSubscription[]
  dataExports              DataExport[]
  verificationApiKeys      VerificationApiKey[]
  instagramVerifications   InstagramVerification[]
  flowkickClients          FlowkickClient[]

  @@index([email])
}

// ============================================================================
// USER MANAGEMENT (Instagram/Manychat Users)
// ============================================================================

model User {
  id              String    @id @default(cuid())
  manychatId      String?   @unique
  igUsername      String?   @unique
  firstName       String?
  lastName        String?
  profilePicUrl   String?
  followerCount   Int?
  lastInteraction DateTime?
  isSubscribed    Boolean   @default(true)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  tags                Tag[]             @relation("UserTags")
  customFieldValues   CustomFieldValue[]
  qrCodes             QRCode[]
  bookings            Booking[]
  conversations       Conversation[]
  interactionHistory  InteractionHistory[]
  snapshots           UserSnapshot[]
  instagramVerifications InstagramVerification[]
  qrSyncLogs          QRSyncLog[]
  qrCampaignProgress  QRCampaignProgress[]
  dataSharingPreferences UserDataSharingPreferences?

  @@index([manychatId])
  @@index([igUsername])
  @@index([createdAt])
}

model UserDataSharingPreferences {
  id        String   @id @default(cuid())
  userId    String   @unique
  
  // Profile data sharing preferences
  shareFirstName     Boolean @default(false)
  shareLastName      Boolean @default(false)
  shareFullName       Boolean @default(false)
  shareProfilePic     Boolean @default(false)
  shareIgUsername     Boolean @default(true)  // Username is usually safe to share
  shareFollowerCount  Boolean @default(false)
  shareEmail          Boolean @default(false)
  sharePhone          Boolean @default(false)
  
  // Custom fields sharing (JSON object: { "fieldName": true/false })
  shareCustomFields   Json?   // { "field_name": true, "another_field": false }
  
  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model Tag {
  id          String   @id @default(cuid())
  name        String
  manychatId  String?  @unique
  adminId     String
  createdAt   DateTime @default(now())

  // Relations
  admin Admin  @relation(fields: [adminId], references: [id], onDelete: Cascade)
  users User[] @relation("UserTags")

  @@index([adminId])
  @@index([name])
}

model CustomField {
  id          String   @id @default(cuid())
  name        String
  fieldType   String   // text, number, date, boolean, json
  description String?
  manychatId  String?  @unique
  createdAt   DateTime @default(now())

  // Relations
  values CustomFieldValue[]

  @@index([name])
}

model CustomFieldValue {
  id        String   @id @default(cuid())
  userId    String
  fieldId   String
  value     String   // Stored as string, parsed by type
  updatedAt DateTime @updatedAt

  // Relations
  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  field CustomField @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([userId, fieldId])
  @@index([userId])
  @@index([fieldId])
}

// ============================================================================
// TOOL MANAGEMENT SYSTEM
// ============================================================================

model Tool {
  id              String   @id @default(cuid())
  adminId         String
  toolType        String   // qr, booking, ai, verification, custom
  name            String
  description     String?
  settings        Json     // Tool-specific configuration
  metadata        Json?    // Custom metadata
  isActive        Boolean  @default(true)
  manychatFlowId  String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  admin             Admin                  @relation(fields: [adminId], references: [id], onDelete: Cascade)
  qrCodes           QRCode[]
  bookings          Booking[]
  availabilities    Availability[]
  conversations     Conversation[]
  dynamicGalleries  DynamicGalleryConfig[]
  qrConfig          QRToolConfig?
  qrCampaignProgress QRCampaignProgress[]

  @@index([adminId])
  @@index([toolType])
  @@index([isActive])
}

// ============================================================================
// DYNAMIC GALLERY
// ============================================================================

enum DynamicGalleryIngestMode {
  immediate_top
  scheduled_top
  scheduled_shuffle
  scheduled_rules
}

model DynamicGalleryConfig {
  id                  String                      @id @default(cuid())
  toolId              String
  name                String                      @default("Default Gallery") // Gallery name (e.g., "Main Menu", "Events")
  displayOrder        Int?                        // Order for gallery list UI
  autoSyncEnabled     Boolean                     @default(true)
  ingestMode          DynamicGalleryIngestMode    @default(immediate_top)
  ingestLimit         Int?
  scheduledTimes      Json?
  shuffleWindows      Json?
  orderingRules       Json?
  stagedPayload       Json?
  lastScheduledSyncAt DateTime?
  lastSyncedAt        DateTime?
  lastWebhookAt       DateTime?
  lastSyncStatus      DynamicGallerySyncStatus?
  createdAt           DateTime                    @default(now())
  updatedAt           DateTime                    @updatedAt

  // Relations
  tool      Tool                     @relation(fields: [toolId], references: [id], onDelete: Cascade)
  snapshots DynamicGallerySnapshot[]
  sources   DynamicGallerySource[]
  secrets   DynamicGallerySecret[]
  syncLogs  DynamicGallerySyncLog[]
  triggers  GalleryTrigger[]

  @@index([toolId])
  @@index([name])
}

model DynamicGallerySnapshot {
  id        String   @id @default(cuid())
  configId  String
  version   Int      @default(1)
  cardCount Int      @default(0)
  cardsJson Json
  hash      String
  createdAt DateTime @default(now())

  // Relations
  config DynamicGalleryConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([createdAt])
  @@index([hash])
}

model DynamicGallerySource {
  id          String                   @id @default(cuid())
  configId    String
  name        String
  sourceType  DynamicGallerySourceType @default(webhook)
  endpoint    String?
  description String?
  headers     Json?
  metadata    Json?
  isActive    Boolean                  @default(true)
  createdAt   DateTime                 @default(now())
  updatedAt   DateTime                 @updatedAt

  // Relations
  config DynamicGalleryConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([isActive])
  @@index([sourceType])
}

model DynamicGallerySecret {
  id              String   @id @default(cuid())
  configId        String
  label           String
  encryptedSecret String
  lastUsedAt      DateTime?
  createdAt       DateTime @default(now())
  revokedAt       DateTime?

  // Relations
  config DynamicGalleryConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([label])
  @@index([revokedAt])
}

model DynamicGallerySyncLog {
  id               String                      @id @default(cuid())
  configId         String
  triggerType      DynamicGalleryTriggerType
  status           DynamicGallerySyncStatus
  cardCount        Int
  contactsImpacted Int      @default(0)
  durationMs       Int?
  errorMessage     String?  @db.Text
  createdAt        DateTime @default(now())

  // Relations
  config DynamicGalleryConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([triggerType])
  @@index([status])
  @@index([createdAt])
}

model GalleryTrigger {
  id          String   @id @default(cuid())
  configId    String
  triggerType String   // manychat_keyword, manychat_flow, webhook, schedule
  triggerKey  String   // Keyword text (e.g., "MENU", "EVENTS"), flow ID, or schedule ID
  metadata    Json?    // Additional trigger configuration
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  config DynamicGalleryConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
  @@index([triggerType])
  @@index([triggerKey])
  @@index([isActive])
}

// ============================================================================
// QR CODE SYSTEM
// ============================================================================

model QRCode {
  id         String    @id @default(cuid())
  code       String    @unique
  qrType     String    // promotion, validation, discount
  userId     String?
  toolId     String
  metadata   Json?     // Custom data
  expiresAt  DateTime?
  scannedAt  DateTime?
  scanCount  Int       @default(0)

  // Recurring campaign fields
  isRecurring       Boolean  @default(false) // Part of recurring campaign
  previousCodeId    String?  // Link to previous code in chain
  nextCodeId        String?  // Link to next generated code
  campaignProgress  Int      @default(0)     // User's progress when this code was generated
  isRewardCode      Boolean  @default(false) // This code represents a reward redemption

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  user          User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  tool          Tool             @relation(fields: [toolId], references: [id], onDelete: Cascade)
  analytics     QRAnalytics[]
  syncLogs      QRSyncLog[]
  previousCode  QRCode?          @relation("QRCodeChain", fields: [previousCodeId], references: [id])
  nextCodes     QRCode[]         @relation("QRCodeChain")

  @@index([code])
  @@index([userId])
  @@index([toolId])
  @@index([qrType])
  @@index([createdAt])
  @@index([isRecurring])
  @@index([previousCodeId])
}

model QRAnalytics {
  id         String   @id @default(cuid())
  qrCodeId   String
  event      String   // generated, scanned, validated
  location   String?  // GPS coordinates (if available)
  device     String?  // Device info
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())

  // Relations
  qrCode QRCode @relation(fields: [qrCodeId], references: [id], onDelete: Cascade)

  @@index([qrCodeId])
  @@index([event])
  @@index([timestamp])
}

model QRSyncLog {
  id           String   @id @default(cuid())
  qrCodeId     String
  userId       String
  trigger      String   // scan, validation
  success      Boolean
  syncedFields Int      @default(0)
  errors       String?  @db.Text
  timestamp    DateTime @default(now())

  // Relations
  qrCode QRCode @relation(fields: [qrCodeId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([qrCodeId])
  @@index([userId])
  @@index([trigger])
  @@index([success])
  @@index([timestamp])
}

model QRCampaignProgress {
  id               String   @id @default(cuid())
  userId           String
  toolId           String
  totalScans       Int      @default(0)    // Total scans across all codes
  currentStreak    Int      @default(0)    // Current progress toward next reward
  rewardsEarned    Int      @default(0)    // Total rewards earned
  lastCodeId       String?  // Most recent code in chain
  lastScanAt       DateTime?
  isActive         Boolean  @default(true) // Whether user can still participate
  metadata         Json?    // Custom campaign data
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@unique([userId, toolId])
  @@index([userId])
  @@index([toolId])
  @@index([isActive])
  @@index([lastScanAt])
}

// ============================================================================
// BOOKING & SCHEDULING SYSTEM
// ============================================================================

model Availability {
  id         String @id @default(cuid())
  toolId     String
  helperName String
  dayOfWeek  Int    // 0-6 (Sunday-Saturday)
  startTime  String // HH:MM format
  endTime    String // HH:MM format
  capacity   Int    @default(1)

  // Relations
  tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@index([toolId])
  @@index([dayOfWeek])
}

model Booking {
  id          String   @id @default(cuid())
  userId      String
  toolId      String
  helperName  String
  bookingDate DateTime
  startTime   String   // HH:MM format
  endTime     String   // HH:MM format
  status      String   // pending, confirmed, completed, cancelled
  serviceType String?
  notes       String?
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  tool Tool @relation(fields: [toolId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([toolId])
  @@index([status])
  @@index([bookingDate])
  @@index([createdAt])
}

// ============================================================================
// AI CHAT SYSTEM
// ============================================================================

model Conversation {
  id        String   @id @default(cuid())
  userId    String
  toolId    String
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  tool     Tool        @relation(fields: [toolId], references: [id], onDelete: Cascade)
  messages AIMessage[]

  @@index([userId])
  @@index([toolId])
  @@index([createdAt])
}

model AIMessage {
  id             String   @id @default(cuid())
  conversationId String
  role           String   // user, assistant, system
  content        String   @db.Text
  tokensUsed     Int?
  timestamp      DateTime @default(now())

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([timestamp])
}

// ============================================================================
// INSTAGRAM VERIFICATION SYSTEM
// ============================================================================

model VerificationApiKey {
  id                  String   @id @default(cuid())
  adminId             String   // Admin who owns this API key
  name                String   // Friendly name (e.g., "My E-commerce Site")
  apiKey              String   @unique // The actual API key (SHA-256 hashed)
  websiteDomain       String   // Domain this key is for
  active              Boolean  @default(true)

  // Rate limiting configuration
  maxRequestsPerHour  Int      @default(100)
  maxRequestsPerDay   Int      @default(1000)

  // Prefix configuration
  servicePrefix       String   // Which prefix this key uses (e.g., "H45", "X7K")

  // Usage tracking
  lastUsedAt          DateTime?
  requestCount        Int      @default(0)

  // Metadata
  metadata            String?  // JSON for webhook URLs, allowed IPs, etc.
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  admin         Admin                   @relation(fields: [adminId], references: [id], onDelete: Cascade)
  verifications InstagramVerification[]

  @@index([adminId])
  @@index([apiKey])
  @@index([active])
}

model InstagramVerification {
  id              String    @id @default(cuid())
  code            String    @unique // Full code (e.g., "H45-73-XYZ")
  servicePrefix   String    // Service identifier (e.g., "H45")
  sessionId       String    // Session identifier (e.g., "73")
  suffix          String    // Random suffix for security (e.g., "XYZ")

  // External website integration
  adminId         String    // Admin who owns this verification service
  externalWebsite String    // Domain or identifier of requesting website
  externalUserId  String?   // External site's user ID (if provided)
  webhookUrl      String?   // URL to POST validation result
  callbackToken   String?   // Secret token for webhook authentication
  apiKeyUsed      String?   // Which API key was used to generate this

  // Instagram user (populated when DM is received)
  userId          String?
  igUsername      String?   // Instagram username who sent the DM
  instagramId     String?   // Instagram platform ID
  manychatUserId  String?   // Manychat subscriber ID

  // Status tracking
  status          String    @default("pending") // pending, verified, expired, failed
  dmReceivedAt    DateTime?
  verifiedAt      DateTime?
  failureReason   String?   // Why validation failed

  // Security & rate limiting
  expiresAt       DateTime  // Short TTL (default 10 minutes)
  attemptCount    Int       @default(0) // Number of validation attempts
  ipAddress       String?   // IP that requested code generation

  // Metadata
  metadata        String?   // JSON for custom data from website
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  admin  Admin                  @relation(fields: [adminId], references: [id], onDelete: Cascade)
  apiKey VerificationApiKey?    @relation(fields: [apiKeyUsed], references: [apiKey])
  user   User?                  @relation(fields: [userId], references: [id])

  @@index([code])
  @@index([adminId])
  @@index([userId])
  @@index([status])
  @@index([expiresAt])
}

// ============================================================================
// FLOWKICK SOCIAL MEDIA DATA SERVICE
// ============================================================================

model FlowkickClient {
  id              String   @id @default(cuid())
  name            String
  apiKey          String   @unique // SHA-256 hashed
  tier            String   // free, starter, pro, enterprise
  requestLimit    Int      // Monthly limit
  requestCount    Int      @default(0) // Current month usage
  allowedPlatforms String[] // instagram, tiktok, google, etc.
  isActive        Boolean  @default(true)
  adminId         String
  webhookUrl      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  admin    Admin       @relation(fields: [adminId], references: [id], onDelete: Cascade)
  apiUsage ApiUsage[]

  @@index([adminId])
  @@index([apiKey])
  @@index([isActive])
}

model SocialMediaCache {
  id           String   @id @default(cuid())
  platform     String   // instagram, tiktok, google, etc.
  identifier   String   // username, handle, place_id
  dataType     String   // posts, reviews, videos
  cachedData   Json
  lastFetched  DateTime @default(now())
  expiresAt    DateTime
  fetchDuration Int?     // milliseconds
  updatedAt    DateTime @updatedAt

  @@unique([platform, identifier, dataType])
  @@index([platform])
  @@index([identifier])
  @@index([expiresAt])
}

model ApifyDataSource {
  id            String   @id @default(cuid())
  platform      String   // instagram, tiktok, google
  actorId       String   // Apify actor ID
  defaultInput  Json     // Default scraper config
  cacheDuration Int      // Hours
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([platform])
  @@index([platform])
  @@index([isActive])
}

model ApiUsage {
  id           String   @id @default(cuid())
  clientId     String
  platform     String
  endpoint     String
  responseTime Int      // milliseconds
  cacheHit     Boolean
  statusCode   Int
  timestamp    DateTime @default(now())

  // Relations
  client FlowkickClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([platform])
  @@index([timestamp])
}

// ============================================================================
// MANYCHAT INTEGRATION
// ============================================================================

model ManychatConfig {
  id          String   @id @default(cuid())
  adminId     String   @unique
  apiToken    String   // Encrypted
  pageToken   String?  // Encrypted
  pageName    String?
  isConnected Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
}

model InteractionHistory {
  id                String   @id @default(cuid())
  userId            String
  date              DateTime
  messageCount      Int      @default(0)
  commentCount      Int      @default(0)
  storyReplyCount   Int      @default(0)
  flowCompletions   Int      @default(0)
  lastActivity      DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}

model UserSnapshot {
  id            String   @id @default(cuid())
  userId        String
  snapshotDate  DateTime
  data          Json     // Full user state
  tags          String[] // Array of tag names
  customFields  Json?    // Custom field values
  followerCount Int?
  createdAt     DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([snapshotDate])
}

model SyncLog {
  id               String   @id @default(cuid())
  syncType         String   // contact, tags, fields, all
  status           String   // success, failed
  recordsProcessed Int      @default(0)
  errorMessage     String?  @db.Text
  duration         Int?     // milliseconds
  timestamp        DateTime @default(now())

  @@index([syncType])
  @@index([status])
  @@index([timestamp])
}

// ============================================================================
// WEBHOOK & CRM INTEGRATION
// ============================================================================

model WebhookSubscription {
  id            String   @id @default(cuid())
  adminId       String
  url           String
  events        String[] // Array of event types
  secret        String   // For HMAC signing
  customHeaders Json?    // Custom headers as JSON
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  admin      Admin             @relation(fields: [adminId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]

  @@index([adminId])
  @@index([isActive])
}

model WebhookDelivery {
  id             String    @id @default(cuid())
  subscriptionId String
  event          String    // Event type
  payload        Json
  status         String    // pending, success, failed
  attempts       Int       @default(0)
  lastAttemptAt  DateTime?
  responseStatus Int?      // HTTP status code
  responseBody   String?   @db.Text
  errorMessage   String?   @db.Text
  nextRetryAt    DateTime?
  createdAt      DateTime  @default(now())

  // Relations
  subscription WebhookSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([status])
  @@index([event])
  @@index([nextRetryAt])
  @@index([createdAt])
}

// ============================================================================
// DATA EXPORT & COMPLIANCE
// ============================================================================

model DataExport {
  id           String   @id @default(cuid())
  adminId      String
  exportType   String   // csv, json, pdf
  filters      Json?    // Export filters applied
  recordCount  Int
  purpose      String?  @db.Text
  downloadUrl  String?
  expiresAt    DateTime?
  createdAt    DateTime @default(now())

  // Relations
  admin Admin @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([exportType])
  @@index([createdAt])
}

// ============================================================================
// INSTAGRAM POST MANAGEMENT
// ============================================================================

model PostCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  color       String?
  icon        String?
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  assignments PostCategoryAssignment[]

  @@index([name])
  @@index([isPublished])
}

model InstagramPost {
  id         String   @id @default(cuid())
  postId     String   @unique // Instagram media ID
  caption    String?  @db.Text
  mediaUrl   String
  mediaType  String   // image, video, carousel
  permalink  String
  likes      Int?
  comments   Int?
  timestamp  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  categories PostCategoryAssignment[]

  @@index([postId])
  @@index([timestamp])
}

model PostCategoryAssignment {
  id         String   @id @default(cuid())
  postId     String
  categoryId String
  order      Int      @default(0)
  assignedAt DateTime @default(now())

  // Relations
  post     InstagramPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  category PostCategory  @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([postId, categoryId])
  @@index([postId])
  @@index([categoryId])
  @@index([order])
}

// ============================================================================
// ERROR MONITORING & SENTRY INTEGRATION
// ============================================================================

model SentryEvent {
  id            String   @id @default(cuid())
  eventId       String   @unique // Sentry's event ID
  level         String   // error, warning, info, debug
  message       String   @db.Text
  culprit       String?  // What caused the error
  platform      String?  // javascript, node

  // Error details
  exception     Json?    // Exception type and value
  stackTrace    Json?    // Full stack trace

  // Context
  environment   String?  // production, development
  release       String?  // App version/release
  url           String?  // URL where error occurred
  userAgent     String?  // Browser user agent

  // User information (if available)
  userId        String?
  userEmail     String?
  userIpAddress String?

  // Metadata
  tags          Json?    // Sentry tags
  contexts      Json?    // Additional context
  breadcrumbs   Json?    // User actions leading to error
  fingerprint   String[] // Error grouping fingerprint

  // Status
  isResolved    Boolean  @default(false)
  resolvedAt    DateTime?

  // Timestamps
  timestamp     DateTime // When error occurred
  receivedAt    DateTime @default(now()) // When we received webhook

  @@index([eventId])
  @@index([level])
  @@index([environment])
  @@index([timestamp])
  @@index([isResolved])
  @@index([userId])
}
